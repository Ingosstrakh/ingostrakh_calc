<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>–ò–ø–æ—Ç–µ—á–Ω—ã–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä ‚Äî v40 (fixed11)</title>
<style>
:root{--bg:#071229;--card:#0b2140;--accent:#2f8ef9;--muted:#9fb7d8;--ok:#c7f0df}
*{box-sizing:border-box}
body{margin:0;font-family:Inter, "Segoe UI", Roboto, Arial;background:linear-gradient(180deg,var(--bg),#021223);color:#e8f6ff}
.container{max-width:1100px;margin:22px auto;padding:18px}
.header{display:flex;gap:12px;align-items:center}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#1f6fe8);display:flex;align-items:center;justify-content:center;font-weight:800;color:#042b4a;font-size:28px}
h1{margin:0;font-size:20px}
.grid{display:grid;grid-template-columns:1fr 380px;gap:18px;margin-top:18px}
.card{background:linear-gradient(180deg,var(--card),rgba(255,255,255,0.02));padding:18px;border-radius:12px;box-shadow:0 8px 36px rgba(0,0,0,0.45)}
label{display:block;color:#cfe9ff;font-weight:600;margin-top:10px;font-size:14px}
input,select,button,textarea{width:100%;padding:10px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:#eaf6ff;outline:none;font-size:14px}
.row{display:flex;gap:10px}
.col{flex:1}
.btn{background:linear-gradient(90deg,var(--accent),#2b7bff);border:none;color:#012;padding:12px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 8px 24px rgba(43,123,255,0.12)}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
.small{font-size:13px;color:var(--muted);margin-top:6px}
.mat-row{display:flex;gap:10px;margin-top:10px}
.mat{flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between;cursor:pointer;color:#eaf6ff;background:transparent}
.mat.active{background:linear-gradient(90deg,rgba(47,142,249,0.12),rgba(47,142,249,0.08));border-color:rgba(47,142,249,0.36);box-shadow:inset 0 -2px 10px rgba(0,0,0,0.3)}
.tooltip{position:relative;display:inline-block}
.tooltip .tip{visibility:hidden;opacity:0;transition:opacity .16s;position:absolute;left:0;top:42px;background:#eaf6ff;color:#012;padding:12px;border-radius:8px;min-width:240px;box-shadow:0 10px 30px rgba(0,0,0,.45);z-index:30}
.tooltip:hover .tip{visibility:visible;opacity:1}
.modal-back{position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999}
.modal{background:#fff;border-radius:12px;padding:18px;max-width:760px;color:#012;max-height:86vh;overflow:auto}
.result-line{display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.03)}
.debug{margin-top:12px;background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;color:#cfe9ff;font-size:13px;display:none;white-space:pre-wrap;overflow:auto;max-height:260px}
.ok-badge{display:inline-block;padding:6px 10px;border-radius:10px;background:var(--ok);color:#032;font-weight:700;margin-bottom:8px}
.co-borrower{border-radius:8px;border:1px solid rgba(255,255,255,0.04);padding:10px;margin-top:10px;background:rgba(255,255,255,0.01)}
.co-row{display:flex;gap:8px;align-items:center}
.co-row input, .co-row select{flex:1}
.small-muted{font-size:12px;color:#9fb7d8;margin-top:6px}
.del-co{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#ffd2d2;cursor:pointer}
.warn{color:#ffb3b3;margin-top:8px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
<div class="header">
<div class="logo">–ò</div>
<div>
<h1>–ò–ø–æ—Ç–µ—á–Ω—ã–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä ‚Äî v40 (fixed11)</h1>
<div class="small">–ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è: —Å–æ–∑–∞–µ–º—â–∏–∫–∏, –¥–æ–º+–∑–µ–º–ª—è —Å –Ω–∞–¥–±–∞–≤–∫–æ–π –∏ –∞–¥–º–∏–Ω/debug.</div>
</div>
</div>
<div class="grid">
<!-- LEFT FORM -->
<div class="card">
<label>–°—É–º–º–∞ –∫—Ä–µ–¥–∏—Ç–∞ (—Ä—É–±)</label>
<input id="loan" type="number" value="6000000"/>
<div class="row">
<div class="col">
<label>–ë–∞–Ω–∫</label>
<select id="bank">
<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –±–∞–Ω–∫</option>
<option>–ê–±—Å–æ–ª—é—Ç</option>
<option>–ê–∫ –ë–∞—Ä—Å</option>
<option>–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫</option>
<option>–í–¢–ë</option>
<option>–î–û–ú.–†–§</option>
<option>–ò–Ω–≤–µ—Å—Ç—Ç–æ—Ä–≥–±–∞–Ω–∫</option>
<option>–ú–µ—Ç–∞–ª–ª–∏–Ω–≤–µ—Å—Ç–±–∞–Ω–∫</option>
<option>–ú–¢–° –ë–∞–Ω–∫</option>
<option>–ü–°–ë</option>
<option>–†–∞–π—Ñ—Ñ–∞–π–∑–µ–Ω–±–∞–Ω–∫</option>
<option>–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫</option>
<option>–°–±–µ—Ä–±–∞–Ω–∫</option>
<option>–£–ë–†–ò–†</option>
<option>–£—Ä–∞–ª—Å–∏–±</option>
<option>–Æ–Ω–∏–ö—Ä–µ–¥–∏—Ç</option>
<option>–ó–µ–Ω–∏—Ç</option>
<option>–¢–ö–ë</option>
<option>–ú–ö–ë</option>
</select>
</div>
<div class="col">
<label>–ù–∞–¥–±–∞–≤–∫–∞ –∫ —Å—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏—é –∂–∏–∑–Ω–∏</label>
<input id="bankMarkup" placeholder="‚Äî" readonly=""/>
</div>
</div>

<div id="vtbRow" style="display:none;margin-top:8px">
<label>–î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–∞ (–¥–ª—è –í–¢–ë)</label>
<input id="vtbDate" type="date"/>
<div class="small">–ï—Å–ª–∏ –¥–∞—Ç–∞ –≤—ã–¥–∞—á–∏ ‚â§ 01.01.2025 ‚Äî –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è —Å—Ç–∞—Ä—ã–µ —Ç–∞—Ä–∏—Ñ—ã –í–¢–ë.</div>
</div>

<div class="row">
<div class="col">
<label>–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è</label>
<input id="birth" type="date"/>
</div>
<div class="col">
<label>–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏—è</label>
<input id="start" type="date"/>
</div>
</div>

<div class="small" id="ageInfo"></div>

<label>–ü–æ–ª</label>
<select id="gender">
<option value="">–ù–µ —É–∫–∞–∑–∞–Ω</option>
<option value="male">–ú—É–∂—á–∏–Ω–∞</option>
<option value="female">–ñ–µ–Ω—â–∏–Ω–∞</option>
</select>

<label>–ß—Ç–æ —Å—Ç—Ä–∞—Ö–æ–≤–∞—Ç—å</label>
<div style="display:flex;gap:12px;align-items:center">
<label><input id="prop" type="checkbox"/> –ò–º—É—â–µ—Å—Ç–≤–æ</label>
<label><input id="title" type="checkbox"/> –¢–∏—Ç—É–ª</label>
<label><input id="life" type="checkbox"/> –ñ–∏–∑–Ω—å</label>
<div class="tooltip" style="margin-left:6px">‚ùî
  <div class="tip">–í–∞–∂–Ω–æ: –¥–ª—è –†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫–∞ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç—å, —Å –≤—Ä–µ–º–µ–Ω–Ω–æ–π —É—Ç—Ä–∞—Ç–æ–π —Ç—Ä—É–¥–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∏–ª–∏ –±–µ–∑ ‚Äî —ç—Ç–æ –ø–æ–≤–ª–∏—è–µ—Ç –Ω–∞ —Ç–∞—Ä–∏—Ñ.</div>
</div>
</div>

<!-- –î–æ–±–∞–≤–∏–ª–∏ –∫–Ω–æ–ø–∫—É –∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Å–æ–∑–∞–µ–º—â–∏–∫–æ–≤ -->
<div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
  <button class="btn secondary" id="addCoBtn">‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–æ–∑–∞–µ–º—â–∏–∫–∞</button>
  <div class="small-muted">–ú–∞–∫—Å–∏–º—É–º 3 —Å–æ–∑–∞–µ–º—â–∏–∫–∞. –î–æ–ª–∏ –≤–≤–æ–¥—è—Ç—Å—è –≤ %.</div>
</div>
<div id="coBorrowersContainer"></div>

<div id="lifeDiscountWrap" style="display:none;margin-top:8px">
<label><input id="lifeDiscount" type="checkbox"/> –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å–∫–∏–¥–∫—É 25% (–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –î–û–ú.–†–§ –∏ –ê–ª—å—Ñ–∞ –ë–∞–Ω–∫–∞)</label>
</div>

<label>–¢–∏–ø –∏–º—É—â–µ—Å—Ç–≤–∞</label>
<select id="propType">
<option value="apartment">–ö–≤–∞—Ä—Ç–∏—Ä–∞</option>
<option value="apt">–ê–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã</option>
<option value="townhouse">–¢–∞—É–Ω—Ö–∞—É—Å</option>
<option value="house">–î–æ–º</option>
</select>

<div id="materialBlock" style="display:none">
<label>–ú–∞—Ç–µ—Ä–∏–∞–ª –Ω–∞—Ä—É–∂–Ω—ã—Ö —Å—Ç–µ–Ω</label>
<div class="mat-row">
<div class="mat" id="matStone"><div>–ö–∞–º–µ–Ω–Ω—ã–π</div><div class="tooltip"><div class="tip"><strong>–ö–∞–º–µ–Ω–Ω—ã–π</strong><br/>–ù–∞—Ä—É–∂–Ω—ã–µ —Å—Ç–µ–Ω—ã –Ω–µ –∏–º–µ—é—Ç –≤ —Å–æ—Å—Ç–∞–≤–µ –¥–µ—Ä–µ–≤–æ. –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ø–µ—Ä–µ–≥–æ—Ä–æ–¥–∫–∏/–æ—Ç–¥–µ–ª–∫–∞ –¥–æ–ø—É—Å–∫–∞—é—Ç—Å—è.</div></div></div>
<div class="mat" id="matWood"><div>–î–µ—Ä–µ–≤—è–Ω–Ω—ã–π</div><div class="tooltip"><div class="tip"><strong>–î–µ—Ä–µ–≤—è–Ω–Ω—ã–π</strong><br/>–û–±—ä–µ–∫—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω –∏–∑ –¥–µ—Ä–µ–≤—è–Ω–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤: –±—Ä—É—Å, –±—Ä–µ–≤–Ω–æ, SIP-–ø–∞–Ω–µ–ª–∏ –∏ –ø—Ä.</div></div></div>
</div>

<!-- New: market house and land fields -->
<div id="houseMarketBlock" style="margin-top:10px;display:none">
  <label>–†—ã–Ω–æ—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–º–∞ (‚ÇΩ)</label>
  <input id="marketHouse" type="number" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É" />
  <div id="marketWarn" class="warn" style="display:none"></div>
  <div id="landBlock" style="margin-top:8px;display:none">
    <label>–°—Ç–æ–∏–º–æ—Å—Ç—å –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ (‚ÇΩ)</label>
    <input id="landValue" type="number" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å —É—á–∞—Å—Ç–∫–∞" />
    <div id="landWarn" class="warn" style="display:none"></div>
  </div>
</div>

<div class="small">–ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å". –ü–æ—è–≤–∏—Ç—Å—è –æ–∫–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º, –µ—Å–ª–∏ —ç—Ç–æ –¥–æ–º.</div>
</div>

<div style="margin-top:14px;display:flex;gap:10px">
<button class="btn" id="calc">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
<button class="btn secondary" id="clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
</div>
<div class="small" style="margin-top:12px">–ü–æ–¥—Å–∫–∞–∑–∫–∏: –î–ª—è –¥–æ–º–∞ ‚Äî –∫–ª–∏–µ–Ω—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º. –ú–ö–ë –∏ –ì–ü–ë ‚Äî –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç.</div>
</div>

<!-- RIGHT RESULTS -->
<div class="card">
<div id="resultTop"></div>
<div id="resultArea" style="margin-top:8px">
<div class="small">–†–µ–∑—É–ª—å—Ç–∞—Ç</div>
<div id="resultsPlaceholder" style="margin-top:10px;color:var(--muted)">–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è –∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–†–∞—Å—Å—á–∏—Ç–∞—Ç—å¬ª.</div>
</div>

<!-- debugWrap: —Å–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞ –∞–¥–º–∏–Ω-–∫–æ–¥–∞ -->
<div id="debugWrap" style="display:none;margin-top:12px">
  <label><input id="showDebug" type="checkbox"/> –ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏ —Ä–∞—Å—á—ë—Ç–∞ (debug –¥–ª—è –∫—É—Ä–∞—Ç–æ—Ä–∞)</label>
  <div class="debug" id="debugBox"></div>
</div>

</div>
</div>

<!-- Modal: House confirmation -->
<div class="modal-back" id="modalHouse">
<div class="modal">
<h3>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º</h3>
<div style="max-height:420px;overflow:auto;padding:8px;color:#012">
<h4>–Æ—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è</h4>
<ul>
<li>–ó–∞—è–≤–ª–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ö–æ–≤–∞—è —Å—É–º–º–∞ –ø–æ –¥–æ–º—É –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –µ–≥–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –≤ –æ—Ç—á—ë—Ç–µ –æ–± –æ—Ü–µ–Ω–∫–µ</li>
<li>–î–æ–º –ø–æ—Å—Ç—Ä–æ–µ–Ω –Ω–µ —Ä–∞–Ω–µ–µ 2000 –≥–æ–¥–∞</li>
<li>–û–±—ä–µ–∫—Ç –Ω–µ –≤ –∑–æ–Ω–µ —Å—Ç–∏—Ö–∏–π–Ω—ã—Ö –±–µ–¥—Å—Ç–≤–∏–π / –≤–æ–µ–Ω–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π</li>
<li>–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—Ä–µ–º–µ–Ω–µ–Ω–∏—è (–∫—Ä–æ–º–µ –∏–ø–æ—Ç–µ–∫–∏)</li>
<li>–ù–∞ –æ–±—ä–µ–∫—Ç–µ –Ω–µ –ø—Ä–æ–≤–æ–¥—è—Ç—Å—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–∞–±–æ—Ç—ã</li>
</ul>
<h4>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è</h4>
<ul>
<li>–í–Ω–µ—à–Ω–∏–µ –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—Ç–µ–Ω—ã –≤–æ–∑–≤–µ–¥–µ–Ω—ã, –∫—Ä—ã—à–∞ –∑–∞–∫—Ä—ã—Ç–∞, –æ–∫–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã</li>
<li>–í –º–∞—Ç–µ—Ä–∏–∞–ª–∞—Ö –Ω–∞—Ä—É–∂–Ω—ã—Ö —Å—Ç–µ–Ω –Ω–µ—Ç –¥–µ—Ä–µ–≤—è–Ω–Ω–æ–≥–æ –∏–ª–∏ –∏–Ω—ã—Ö –≥–æ—Ä—é—á–∏—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ (–µ—Å–ª–∏ –∫–∞–º–µ–Ω–Ω—ã–π)</li>
<li>–í–Ω—É—Ç—Ä–∏ –Ω–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ –æ–≥–Ω—è (–ø–µ—á—å, –∫–∞–º–∏–Ω –∏ —Ç.–¥.)</li>
</ul>
<div class="small">–î–æ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –≤—Å–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º?</div>
</div>
<div style="margin-top:12px;text-align:right">
<button class="btn secondary" id="houseNo">–ù–µ—Ç</button>
<button class="btn" id="houseYes">–î–∞</button>
</div>
</div>
</div>

<!-- Modal: RSHB selection -->
<div class="modal-back" id="modalRshb">
<div class="modal">
<h3>–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫ ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º</h3>
<div style="padding:8px;color:#012">
<label><input name="rshbMode" type="radio" value="without"/> –ë–µ–∑ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —É—Ç—Ä–∞—Ç—ã —Ç—Ä—É–¥–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏</label><br/>
<label><input name="rshbMode" type="radio" value="with"/> –° –≤—Ä–µ–º–µ–Ω–Ω–æ–π —É—Ç—Ä–∞—Ç—ã —Ç—Ä—É–¥–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏</label>
<div class="small">–í—ã–±–æ—Ä –≤–ª–∏—è–µ—Ç –Ω–∞ —Ç–∞—Ä–∏—Ñ—ã –ø–æ –∂–∏–∑–Ω–∏.</div>
</div>
<div style="margin-top:12px;text-align:right">
<button class="btn secondary" id="rshbCancel">–û—Ç–º–µ–Ω–∞</button>
<button class="btn" id="rshbOk">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
</div>
</div>
</div>

<script>
/* ========== Data ========== */
const maleTable = {18:0.119,19:0.129,20:0.140,21:0.150,22:0.161,23:0.172,24:0.182,25:0.193,26:0.203,27:0.214,28:0.214,29:0.214,30:0.214,31:0.214,32:0.214,33:0.227,34:0.240,35:0.252,36:0.265,37:0.278,38:0.324,39:0.371,40:0.418,41:0.464,42:0.511,43:0.527,44:0.544,45:0.561,46:0.577,47:0.594,48:0.680,49:0.765,50:0.851,51:0.937,52:1.023,53:1.161,54:1.300,55:1.439,56:1.578,57:1.717,58:1.856,59:1.995,60:2.134,61:2.273,62:2.412,63:2.551,64:2.689};
const femaleTable = {18:0.091,19:0.091,20:0.092,21:0.093,22:0.093,23:0.094,24:0.095,25:0.095,26:0.096,27:0.097,28:0.097,29:0.098,30:0.109,31:0.126,32:0.142,33:0.152,34:0.162,35:0.173,36:0.183,37:0.193,38:0.206,39:0.220,40:0.233,41:0.246,42:0.259,43:0.291,44:0.322,45:0.354,46:0.385,47:0.417,48:0.462,49:0.507,50:0.552,51:0.598,52:0.643,53:0.721,54:0.799,55:0.876,56:0.954,57:1.032,58:1.110,59:1.188,60:1.266,61:1.344,62:1.422,63:1.499,64:1.577};

const domrfPropRate = 0.144;
const domrfMale = {21:0.287,22:0.296,23:0.296,24:0.325,25:0.325,26:0.325,27:0.333,28:0.333,29:0.373,30:0.38,31:0.399,32:0.416,33:0.428,34:0.464,35:0.482,36:0.527,37:0.555,38:0.584,39:0.62,40:0.649,41:0.685,42:0.724,43:0.768,44:0.806,45:0.844,46:0.935,47:1.009,48:1.101,49:1.195,50:1.307,51:1.427,52:1.643,53:1.791,54:1.959,55:2.126,56:2.302,57:2.518,58:2.756,59:3.68,60:4.103,61:4.56,62:5.053,63:5.564,64:6.076};
const domrfFemale = {21:0.222,22:0.222,23:0.222,24:0.233,25:0.233,26:0.25,27:0.25,28:0.26,29:0.26,30:0.26,31:0.269,32:0.287,33:0.296,34:0.296,35:0.325,36:0.352,37:0.38,38:0.39,39:0.416,40:0.428,41:0.454,42:0.482,43:0.511,44:0.547,45:0.575,46:0.611,47:0.658,48:0.705,49:0.751,50:0.806,51:0.871,52:0.993,53:1.063,54:1.162,55:1.249,56:1.348,57:1.477,58:1.594,59:2.518,60:2.817,61:3.134,62:3.468,63:3.803,64:4.138};

/* === bank life markup map (from –ù–∞–¥–±–∞–≤–∫–∞.txt) === */
const bankLifeMap = {
  "–ê–±—Å–æ–ª—é—Ç": 0,
  "–ê–∫ –ë–∞—Ä—Å": 0,
  "–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫": "input",
  "–í–¢–ë": 10,
  "–î–û–ú.–†–§": 0,
  "–ò–Ω–≤–µ—Å—Ç—Ç–æ—Ä–≥–±–∞–Ω–∫": 10,
  "–ú–µ—Ç–∞–ª–ª–∏–Ω–≤–µ—Å—Ç–±–∞–Ω–∫": 10,
  "–ú–¢–° –ë–∞–Ω–∫": 10,
  "–ü–°–ë": 0,
  "–†–∞–π—Ñ—Ñ–∞–π–∑–µ–Ω–±–∞–Ω–∫": 10,
  "–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫": 10,
  "–°–±–µ—Ä–±–∞–Ω–∫": 0,
  "–£–ë–†–ò–†": "input",
  "–£—Ä–∞–ª—Å–∏–±": 0,
  "–Æ–Ω–∏–ö—Ä–µ–¥–∏—Ç": 0,
  "–ó–µ–Ω–∏—Ç": 10,
  "–¢–ö–ë": 10,
  "–ú–ö–ë": 0
};

/* ========== UI refs ========== */
const bankEl = document.getElementById('bank'), bankMarkupEl = document.getElementById('bankMarkup'), vtbRow = document.getElementById('vtbRow');
const lifeChk = document.getElementById('life'), lifeDiscountWrap = document.getElementById('lifeDiscountWrap'), lifeDiscount = document.getElementById('lifeDiscount');
const propType = document.getElementById('propType'), materialBlock = document.getElementById('materialBlock');
const matStone = document.getElementById('matStone'), matWood = document.getElementById('matWood');
const modalHouse = document.getElementById('modalHouse'), houseYes = document.getElementById('houseYes'), houseNo = document.getElementById('houseNo');
const modalRshb = document.getElementById('modalRshb'), rshbOk = document.getElementById('rshbOk'), rshbCancel = document.getElementById('rshbCancel');
const calcBtn = document.getElementById('calc'), clearBtn = document.getElementById('clear');
const resultsPlaceholder = document.getElementById('resultsPlaceholder'), debugBox = document.getElementById('debugBox');
const showDebug = document.getElementById('showDebug'), ageInfo = document.getElementById('ageInfo');
const addCoBtn = document.getElementById('addCoBtn'), coContainer = document.getElementById('coBorrowersContainer');
const houseMarketBlock = document.getElementById('houseMarketBlock'), marketHouseEl = document.getElementById('marketHouse'), landBlock = document.getElementById('landBlock'), landValueEl = document.getElementById('landValue');
const marketWarn = document.getElementById('marketWarn'), landWarn = document.getElementById('landWarn');

let chosenMaterial = null, houseConfirmed = false, rshbMode = null;

/* ========== Helpers ========== */
function parseDateISO(v){ if(!v) return null; return new Date(v+'T00:00:00'); }
function calcAge(birthISO, refISO){ const b=parseDateISO(birthISO); if(!b) return null; const r = refISO ? parseDateISO(refISO) : new Date(); let age = r.getFullYear()-b.getFullYear(); const m = r.getMonth()-b.getMonth(); if(m<0 || (m===0 && r.getDate()<b.getDate())) age--; return age; }
function money(x){ return Number(x).toLocaleString('ru-RU',{minimumFractionDigits:2,maximumFractionDigits:2}) + ' ‚ÇΩ'; }
function showModal(id){ document.getElementById(id).style.display='flex'; }
function hideModal(id){ document.getElementById(id).style.display='none'; }

/* ========== Events ========== */
bankEl.addEventListener('change', ()=>{
  const b = bankEl.value; const map = bankLifeMap[b];
  if(map === undefined) bankMarkupEl.value = '‚Äî';
  else if(map === 'input') bankMarkupEl.value = '–í–≤–æ–¥';
  else bankMarkupEl.value = map + '%';
  vtbRow.style.display = (b === '–í–¢–ë') ? 'block' : 'none';
  if(b === '–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫'){ showModal('modalRshb'); }
  if(b === '–î–û–ú.–†–§' || b === '–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫'){ lifeDiscount.checked = false; lifeDiscount.disabled = true; lifeDiscountWrap.style.display = lifeChk.checked ? 'block' : 'none'; } else { lifeDiscount.disabled = false; }
  // when bank changes, update borrower share display
  updateBorrowerShareDisplay();
});

// show house market block when prop checkbox toggled and type==house
document.getElementById('prop').addEventListener('change', ()=> {
  const propChecked = document.getElementById('prop').checked;
  if(propChecked && propType.value === 'house'){
    houseMarketBlock.style.display = 'block';
  } else {
    houseMarketBlock.style.display = 'none';
    landBlock.style.display = 'none';
    marketWarn.style.display = 'none';
    landWarn.style.display = 'none';
  }
});

lifeChk.addEventListener('change', ()=>{ lifeDiscountWrap.style.display = lifeChk.checked ? 'block' : 'none'; });
propType.addEventListener('change', ()=>{ 
  materialBlock.style.display = (propType.value === 'house') ? 'block' : 'none';
  // show market block if house and prop checked
  houseMarketBlock.style.display = (propType.value === 'house' && document.getElementById('prop').checked) ? 'block' : 'none';
});
matStone.addEventListener('click', ()=>{ chosenMaterial='stone'; matStone.classList.add('active'); matWood.classList.remove('active'); });
matWood.addEventListener('click', ()=>{ chosenMaterial='wood'; matWood.classList.add('active'); matStone.classList.remove('active'); });
showDebug.addEventListener('change', ()=>{ debugBox.style.display = showDebug.checked ? 'block' : 'none'; });
rshbCancel.addEventListener('click', ()=>{ hideModal('modalRshb'); rshbMode = null; });
rshbOk.addEventListener('click', ()=>{
  const sel = document.querySelector('input[name="rshbMode"]:checked');
  if(!sel){ alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –¥–ª—è –†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫–∞'); return; }
  rshbMode = sel.value; hideModal('modalRshb');
});
houseNo.addEventListener('click', ()=>{ hideModal('modalHouse'); houseConfirmed = false; alert('–î–æ–º –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∫—É—Ä–∞—Ç–æ—Ä—É.'); });
houseYes.addEventListener('click', ()=>{ hideModal('modalHouse'); houseConfirmed = true; proceedCalculation(true); });
clearBtn.addEventListener('click', ()=>{ // clear everything incl. co-borrowers
  document.getElementById('loan').value=''; bankEl.value=''; bankMarkupEl.value=''; document.getElementById('birth').value=''; document.getElementById('start').value=''; document.getElementById('vtbDate').value=''; document.getElementById('gender').value=''; document.getElementById('prop').checked=false; document.getElementById('title').checked=false; document.getElementById('life').checked=false; lifeDiscount.checked=false; lifeDiscountWrap.style.display='none'; propType.value='apartment'; materialBlock.style.display='none'; matStone.classList.remove('active'); matWood.classList.remove('active'); chosenMaterial=null; resultsPlaceholder.innerHTML='–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è –∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–†–∞—Å—Å—á–∏—Ç–∞—Ç—å¬ª.';
  // remove all co-borrowers
  coContainer.innerHTML = '';
  addCoBtn.disabled = false;
  // hide house blocks
  houseMarketBlock.style.display = 'none';
  landBlock.style.display = 'none';
  marketWarn.style.display = 'none';
  landWarn.style.display = 'none';
  updateBorrowerShareDisplay();
});
marketHouseEl.addEventListener('input', ()=>{
  const loan = Number(document.getElementById('loan').value)||0;
  const val = Number(marketHouseEl.value)||0;
  marketWarn.style.display = 'none';
  landWarn.style.display = 'none';
  if(val < loan){
    landBlock.style.display = 'block';
  } else {
    landBlock.style.display = 'none';
  }
});
landValueEl.addEventListener('input', ()=>{ landWarn.style.display = 'none'; });
document.getElementById('birth').addEventListener('change', updateAgeInfo);
document.getElementById('start').addEventListener('change', updateAgeInfo);
function updateAgeInfo(){ const age = calcAge(document.getElementById('birth').value, document.getElementById('start').value); ageInfo.textContent = age!==null ? '–í–æ–∑—Ä–∞—Å—Ç: ' + age + ' –ª–µ—Ç' : ''; }

/* ========== Co-borrowers logic ========== */
let coCount = 0;
function createCoBlock(index){
  const wrapper = document.createElement('div');
  wrapper.className = 'co-borrower';
  wrapper.id = 'coBorrower' + index;
  wrapper.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>–°–æ–∑–∞–µ–º—â–∏–∫ ${index}</strong>
      <button class="del-co" data-id="${index}" title="–£–¥–∞–ª–∏—Ç—å —Å–æ–∑–∞–µ–º—â–∏–∫–∞">–£–¥–∞–ª–∏—Ç—å</button>
    </div>
    <div class="co-row" style="margin-top:8px">
      <input type="date" id="coBirth${index}" placeholder="–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è" />
      <select id="coGender${index}">
        <option value="">–ü–æ–ª</option>
        <option value="male">–ú—É–∂—á–∏–Ω–∞</option>
        <option value="female">–ñ–µ–Ω—â–∏–Ω–∞</option>
      </select>
      <input type="number" id="coShare${index}" min="0" max="1000" value="50" title="–î–æ–ª—è –≤ % (–≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ)" />
    </div>
    <div class="small-muted">–î–æ–ª—è –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (–≤–≤–µ–¥–∏—Ç–µ –≤—Ä—É—á–Ω—É—é). –î–ª—è –±–∞–Ω–∫–æ–≤, –∫—Ä–æ–º–µ –í–¢–ë, —Å—É–º–º–∞ –¥–æ–ª–µ–π –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –¥–æ–ª–∂–Ω–∞ —Ä–∞–≤–Ω—è—Ç—å—Å—è 100%.</div>
  `;
  // delete handler
  wrapper.querySelector('.del-co').addEventListener('click', (e)=>{
    const id = e.currentTarget.getAttribute('data-id');
    const el = document.getElementById('coBorrower'+id);
    if(el) el.remove();
    coCount--;
    addCoBtn.disabled = false;
    updateBorrowerShareDisplay();
  });
  return wrapper;
}
addCoBtn.addEventListener('click', ()=>{
  if(coCount >= 3) return;
  coCount++;
  const block = createCoBlock(coCount);
  coContainer.appendChild(block);
  if(coCount >= 3) addCoBtn.disabled = true;
  updateBorrowerShareDisplay();
});
function readCoBorrowers(){
  const arr = [];
  for(let i=1;i<=3;i++){
    const el = document.getElementById('coBorrower'+i);
    if(!el) continue;
    const birth = document.getElementById('coBirth'+i).value;
    const gender = document.getElementById('coGender'+i).value;
    const shareRaw = Number(document.getElementById('coShare'+i).value);
    const share = isFinite(shareRaw) ? shareRaw : 0;
    arr.push({index:i, birth, gender, share});
  }
  return arr;
}
function updateBorrowerShareDisplay(){
  // silent for now
}

/* ========== Core functions ========== */
function getBasePercentForBank(bank, age, gender){
  if(age===null) return null;
  if(age < 18 || age > 64) return null;
  if(bank === '–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫'){
    if(!rshbMode) return null;
    if(gender === 'female'){
      return (rshbMode === 'with') ? rshbFemaleWithDis[age] : rshbFemaleNoDis[age];
    } else {
      return (rshbMode === 'with') ? rshbMaleWithDis[age] : rshbMaleNoDis[age];
    }
  }
  return (gender === 'female') ? femaleTable[age] : maleTable[age];
}
function calcClick(){
  const loan = Number(document.getElementById('loan').value) || 0;
  const bank = (bankEl.value||'').toString().trim();
  const propChecked = document.getElementById('prop').checked;
  const titleChecked = document.getElementById('title').checked;
  const lifeChecked = document.getElementById('life').checked;
  const propTypeVal = propType.value;
  const birth = document.getElementById('birth').value;
  const start = document.getElementById('start').value;
  const gender = document.getElementById('gender').value;
  const discount = document.getElementById('lifeDiscount').checked && !document.getElementById('lifeDiscount').disabled;
  if(!loan){ alert('–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –∫—Ä–µ–¥–∏—Ç–∞'); return; }
  if(!bank){ alert('–í—ã–±–µ—Ä–∏—Ç–µ –±–∞–Ω–∫'); return; }
  if(lifeChecked && !gender){ alert('–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –∂–∏–∑–Ω–∏'); return; }
  if(propTypeVal === 'house' && !chosenMaterial){ alert('–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç–µ—Ä–∏–∞–ª –Ω–∞—Ä—É–∂–Ω—ã—Ö —Å—Ç–µ–Ω: –∫–∞–º–µ–Ω–Ω—ã–π –∏–ª–∏ –¥–µ—Ä–µ–≤—è–Ω–Ω—ã–π'); return; }
  if(propTypeVal === 'house' && !houseConfirmed){ showModal('modalHouse'); return; }
  proceedCalculation(false);
}
function proceedCalculation(fromModal){
  const loan = Number(document.getElementById('loan').value) || 0;
  const bank = (bankEl.value||'').toString().trim();
  const propChecked = document.getElementById('prop').checked;
  const titleChecked = document.getElementById('title').checked;
  const lifeChecked = document.getElementById('life').checked;
  const propTypeVal = propType.value;
  const birth = document.getElementById('birth').value;
  const start = document.getElementById('start').value;
  const gender = document.getElementById('gender').value;
  const discount = document.getElementById('lifeDiscount').checked && !document.getElementById('lifeDiscount').disabled;

  // compute bank markup
  let bankMarkup = undefined;
  if(bank && typeof bankLifeMap !== 'undefined') bankMarkup = bankLifeMap[bank];
  let bankMarkupNum = 0;
  if(bankMarkup === undefined){
    bankMarkupNum = 0;
  } else if(bankMarkup === 'input'){
    const txt = prompt('–£–∫–∞–∂–∏—Ç–µ –Ω–∞–¥–±–∞–≤–∫—É –±–∞–Ω–∫–∞ –≤ % (–Ω–∞–ø—Ä–∏–º–µ—Ä 5)');
    bankMarkupNum = Number(txt) || 0;
  } else {
    bankMarkupNum = Number(bankMarkup) || 0;
  }
  const loanWithMarkup = loan * (1 + bankMarkupNum/100.0);

  // debug holder
  const debug = {bank:bank, bankMarkup:bankMarkupNum, loan, loanWithMarkup, age:null, basePercent:null, finalRate:null, participants:[]};

  // prepare lines
  let lines = [];
  lines.push({label:'üí∞ –°—Ç—Ä–∞—Ö–æ–≤–∞—è —Å—É–º–º–∞', value: loan, isSum:true});
  if(bankMarkupNum !== 0){
    lines.push({label:'üî∫ –°—É–º–º–∞ —Å –Ω–∞–¥–±–∞–≤–∫–æ–π', value: loanWithMarkup, isSum:false, type:'markup'});
  }

  // property
  if(propChecked){
    if(propTypeVal === 'house'){
      // special logic using marketHouse and landValue
      const marketHouse = Number(marketHouseEl.value) || 0;
      const landValue = Number(landValueEl.value) || 0;
      marketWarn.style.display = 'none'; landWarn.style.display = 'none';
      if(marketHouse <= 0){
        alert('–í–≤–µ–¥–∏—Ç–µ —Ä—ã–Ω–æ—á–Ω—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–º–∞'); return;
      }

      // Use rounded comparisons to avoid floating-point edge cases
      const roundedMarketHouse = Math.round(marketHouse);
      const roundedLoanWithMarkup = Math.round(loanWithMarkup);

      // if marketHouse < loanWithMarkup then land may be required
      if(roundedMarketHouse < roundedLoanWithMarkup){
        // Show land input if not visible and wait for user to fill
        landBlock.style.display = 'block';
        if(landValue <= 0){
          marketWarn.textContent = '–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞';
          marketWarn.style.display = 'block';
          return;
        }
        // Now user entered landValue; validate totals against loanWithMarkup
        const total = marketHouse + landValue;
        const roundedTotal = Math.round(total);
        if(roundedTotal < roundedLoanWithMarkup){
          // warning: refer to curator
          marketWarn.textContent = '–†—ã–Ω–æ—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–º–∞ –∏ —É—á–∞—Å—Ç–∫–∞ –º–µ–Ω—å—à–µ —Å—É–º–º—ã –∫—Ä–µ–¥–∏—Ç–∞ —Å –Ω–∞–¥–±–∞–≤–∫–æ–π ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∫—É—Ä–∞—Ç–æ—Ä—É.';
          marketWarn.style.display = 'block';
          return;
        }
        if(roundedTotal > roundedLoanWithMarkup){
          marketWarn.textContent = '–°—É–º–º–∞ –¥–æ–º–∞ –∏ —É—á–∞—Å—Ç–∫–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç —Å—É–º–º—É –∫—Ä–µ–¥–∏—Ç–∞ —Å –Ω–∞–¥–±–∞–≤–∫–æ–π ‚Äî –∏—Å–ø—Ä–∞–≤—å—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è.';
          marketWarn.style.display = 'block';
          return;
        }
        // compute per-material rates
        const ratePercent = (chosenMaterial === 'stone') ? 0.18 : 0.43;
        // IMPORTANT CHANGE: house and land insured ON THEIR FACTUAL VALUES (WITHOUT BANK MARKUP)
        const houseSum = marketHouse * (ratePercent/100.0);
        const landSum = landValue * 0.001; // 0.1% -> 0.001
        lines.push({label:'üè† –°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞', value: houseSum, rate: ratePercent, type:'prop'});
        lines.push({label:'üå≥ –ó–µ–º–µ–ª—å–Ω—ã–π —É—á–∞—Å—Ç–æ–∫', value: landSum, rate: 0.1, type:'prop'});
      } else {
        // marketHouse >= loanWithMarkup ‚Äî insure house for marketHouse but land not needed
        const ratePercent = (chosenMaterial === 'stone') ? 0.18 : 0.43;
        // IMPORTANT CHANGE: use marketHouse ( factual ) for calculation
        const houseSum = marketHouse * (ratePercent/100.0);
        lines.push({label:'üè† –°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞', value: houseSum, rate: ratePercent, type:'prop'});
      }
    } else {
      // non-house property uses loanWithMarkup per previous logic
      let ratePercent = 0.09; // default for apartment
      let label = '–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã';
      if(bank === '–î–û–ú.–†–§'){
        if(propTypeVal === 'apartment' || propTypeVal === 'apt') { ratePercent = 0.144; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã/–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç–æ–≤ (–î–û–ú.–†–§)'; }
        else if(propTypeVal === 'townhouse') { ratePercent = 0.15; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ —Ç–∞—É–Ω—Ö–∞—É—Å–∞ (–î–û–ú.–†–§)'; }
        else if(propTypeVal === 'house') { ratePercent = (chosenMaterial === 'stone') ? 0.18 : 0.43; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞ (–î–û–ú.–†–§)'; }
      } else {
        if(propTypeVal === 'apartment'){ ratePercent = 0.09; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã'; }
        if(propTypeVal === 'apt'){ ratePercent = 0.10; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç–æ–≤'; }
        if(propTypeVal === 'townhouse'){ ratePercent = 0.15; label='–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ —Ç–∞—É–Ω—Ö–∞—É—Å–∞'; }
        if(propTypeVal === 'house'){ ratePercent = (chosenMaterial === 'stone') ? 0.18 : 0.43; label = (chosenMaterial === 'stone') ? '–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞ (–∫–∞–º–µ–Ω–Ω—ã–π)' : '–°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞ (–¥–µ—Ä–µ–≤—è–Ω–Ω—ã–π)'; }
      }
      const propSum = loanWithMarkup * (ratePercent / 100.0);
      lines.push({label: 'üè† ' + label, value: propSum, rate: ratePercent, type:'prop'});
    }
  }

  // title always 0.2%
  if(titleChecked){
    const t = loanWithMarkup * 0.002;
    lines.push({label:'üìú –°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ —Ç–∏—Ç—É–ª–∞', value: t, rate: 0.2, type:'title'});
  }

  // life: handle borrower + co-borrowers
  if(lifeChecked){
    const coArr = readCoBorrowers(); // [{index, birth, gender, share}]
    let sumCo = 0;
    for(const c of coArr) sumCo += Number(c.share) || 0;

    let borrowerShare;
    if(bank === '–í–¢–ë'){
      borrowerShare = 100;
    } else {
      if(sumCo > 100){ alert('–°—É–º–º–∞ –¥–æ–ª–µ–π —Å–æ–∑–∞–µ–º—â–∏–∫–æ–≤ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 100% ‚Äî –∏—Å–ø—Ä–∞–≤—å—Ç–µ –¥–æ–ª–∏ –∏–ª–∏ —É–¥–∞–ª–∏—Ç–µ —Å–æ–∑–∞–µ–º—â–∏–∫–∞.'); return; }
      borrowerShare = Math.max(0, 100 - sumCo);
    }

    // Borrower
    const borrowerAge = calcAge(birth, start);
    debug.age = borrowerAge;
    const borrowerBasePercent = getBasePercentForBank(bank, borrowerAge, gender);
    debug.basePercent = borrowerBasePercent;
    if(borrowerBasePercent === null){
      lines.push({label:'‚ù§Ô∏è –°—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –∂–∏–∑–Ω–∏ (–∑–∞–µ–º—â–∏–∫)', value: null, note:'–í–æ–∑—Ä–∞—Å—Ç –∑–∞–µ–º—â–∏–∫–∞ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∫—É—Ä–∞—Ç–æ—Ä—É.'});
    } else {
      let effPercent = borrowerBasePercent;
      if(discount && !['–î–û–ú.–†–§','–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫'].includes(bank)) effPercent = effPercent * 0.75;
      const borrowerSum = loanWithMarkup * (borrowerShare/100.0) * (effPercent / 100.0);
      lines.push({label:'‚ù§Ô∏è –ñ–∏–∑–Ω—å (–∑–∞–µ–º—â–∏–∫)', value: borrowerSum, rate: effPercent, share: borrowerShare, type:'life'});
      debug.participants.push({role:'borrower', age: borrowerAge, gender, share: borrowerShare, rate: effPercent, sum: borrowerSum});
    }

    // co-borrowers
    for(const c of coArr){
      const cAge = calcAge(c.birth, start);
      const cBase = getBasePercentForBank(bank, cAge, c.gender);
      if(cBase === null){
        lines.push({label:`‚ù§Ô∏è –ñ–∏–∑–Ω–∞–Ω–∏–µ (—Å–æ–∑–∞–µ–º—â–∏–∫ ${c.index})`, value: null, note:'–í–æ–∑—Ä–∞—Å—Ç —Å–æ–∑–∞–µ–º—â–∏–∫–∞ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∫—É—Ä–∞—Ç–æ—Ä—É.'});
        debug.participants.push({role:'co'+c.index, age:cAge, gender:c.gender, share:c.share, rate:null, sum:null});
      } else {
        let cEff = cBase;
        if(discount && !['–î–û–ú.–†–§','–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫'].includes(bank)) cEff = cEff * 0.75;
        const cSum = loanWithMarkup * ( (Number(c.share)||0) / 100.0 ) * (cEff / 100.0);
        lines.push({label:`‚ù§Ô∏è –ñ–∏–∑–Ω–∞–Ω–∏–µ (—Å–æ–∑–∞–µ–º—â–∏–∫ ${c.index})`, value: cSum, rate: cEff, share: c.share, type:'life'});
        debug.participants.push({role:'co'+c.index, age:cAge, gender:c.gender, share:c.share, rate:cEff, sum:cSum});
      }
    }
  }

  // compute premium: sum only risk lines (prop, title, life)
  let premium = 0;
  for(const it of lines){
    if(it.type && (it.type === 'prop' || it.type === 'title' || it.type === 'life')){
      if(it.value && typeof it.value === 'number') premium += it.value;
    }
  }

  // render client-facing result
  let html = '';
  html += `<div class="ok-badge">–û—Ç—á—ë—Ç —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω (–ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ)</div>`;
  html += `<div class="result-line"><div>üí∞ –°—Ç—Ä–∞—Ö–æ–≤–∞—è —Å—É–º–º–∞</div><div>${money(loan)}</div></div>`;
  if(bankMarkupNum !== 0){
    html += `<div class="result-line"><div>üî∫ –°—É–º–º–∞ —Å –Ω–∞–¥–±–∞–≤–∫–æ–π</div><div>${money(loanWithMarkup)}</div></div>`;
  }
  // render risk lines only
  for(const it of lines){
    if(it.type && (it.type === 'prop' || it.type === 'title' || it.type === 'life')){
      if(it.value === null){
        html += `<div style="padding:8px 0;color:#ffddcc">${it.label}: ${it.note || '‚Äî'}</div>`;
      } else {
        if(it.type === 'life' && it.share !== undefined){
          html += `<div class="result-line"><div>${it.label} (${it.share}%)</div><div>${money(it.value)}</div></div>`;
        } else {
          html += `<div class="result-line"><div>${it.label}</div><div>${money(it.value)}</div></div>`;
        }
      }
    }
  }
  html += `<div style="padding-top:8px;font-weight:700;color:#dff">–ò—Ç–æ–≥–æ —Å—Ç—Ä–∞—Ö–æ–≤–∞—è –ø—Ä–µ–º–∏—è: <span style="float:right">${money(premium)}</span></div>`;
  resultsPlaceholder.innerHTML = html;

  // debug for curator
  const debugObj = {lines, debug};
  debugBox.textContent = JSON.stringify(debugObj, null, 2);
  if(showDebug && showDebug.checked) debugBox.style.display = 'block'; else debugBox.style.display = 'none';
}

/* attach */
document.getElementById('calc').addEventListener('click', calcClick);

/* init */
updateAgeInfo();

/* === –†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫ tables === */
const rshbMaleNoDis = {18:0.119,19:0.129,20:0.140,21:0.150,22:0.161,23:0.172,24:0.182,25:0.193,26:0.203,27:0.214,28:0.214,29:0.214,30:0.214,31:0.214,32:0.214,33:0.227,34:0.240,35:0.252,36:0.265,37:0.278,38:0.324,39:0.371,40:0.418,41:0.464,42:0.511,43:0.527,44:0.544,45:0.561,46:0.577,47:0.594,48:0.680,49:0.765,50:0.851,51:0.937,52:1.023,53:1.161,54:1.300,55:1.439,56:1.578,57:1.717,58:1.856,59:1.995,60:2.134,61:2.273,62:2.412,63:2.551,64:2.689};
const rshbMaleWithDis = {18:0.217,19:0.237,20:0.256,21:0.276,22:0.295,23:0.314,24:0.334,25:0.353,26:0.373,27:0.392,28:0.392,29:0.392,30:0.392,31:0.392,32:0.392,33:0.415,34:0.439,35:0.463,36:0.485,37:0.509,38:0.594,39:0.680,40:0.765,41:0.85,42:0.935,43:0.965,44:0.996,45:1.027,46:1.058,47:1.088,48:1.245,49:1.402,50:1.559,51:1.716,52:1.873,53:2.128,54:2.382,55:2.636,56:2.89,57:3.145,58:3.399,59:3.654,60:3.908,61:4.163,62:4.417,63:4.671,64:4.926};
const rshbFemaleNoDis = {18:0.091,19:0.091,20:0.092,21:0.093,22:0.093,23:0.094,24:0.095,25:0.095,26:0.096,27:0.097,28:0.097,29:0.098,30:0.109,31:0.126,32:0.142,33:0.152,34:0.162,35:0.173,36:0.183,37:0.193,38:0.206,39:0.220,40:0.233,41:0.246,42:0.259,43:0.291,44:0.322,45:0.354,46:0.385,47:0.417,48:0.462,49:0.507,50:0.552,51:0.598,52:0.643,53:0.721,54:0.799,55:0.876,56:0.954,57:1.032,58:1.110,59:1.188,60:1.266,61:1.344,62:1.422,63:1.499,64:1.577};
const rshbFemaleWithDis = {18:0.166,19:0.168,20:0.168,21:0.17,22:0.171,23:0.172,24:0.173,25:0.174,26:0.175,27:0.177,28:0.178,29:0.179,30:0.2,31:0.23,32:0.26,33:0.278,34:0.297,35:0.316,36:0.335,37:0.354,38:0.378,39:0.402,40:0.426,41:0.45,42:0.475,43:0.533,44:0.591,45:0.648,46:0.706,47:0.764,48:0.846,49:0.929,50:1.012,51:1.094,52:1.177,53:1.32,54:1.462,55:1.605,56:1.748,57:1.891,58:2.033,59:2.176,60:2.318,61:2.46,62:2.604,63:2.746,64:2.889};

</script>



<!-- ========== START: Admin-only GPT Autofil block ========== -->
<style id="gpt_admin_styles">
  /* Minimal isolated styles ‚Äî safe to inject at page end */
  #gpt-admin-lock {
    position: fixed;
    right: 18px;
    bottom: 18px;
    z-index: 999999;
    background: rgba(0,0,0,0.55);
    color: #fff;
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    font-family: Arial, sans-serif;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }
  #gpt-admin-shell {
    position: fixed;
    right: 18px;
    bottom: 18px;
    width: 380px;
    max-width: 92vw;
    z-index: 999999;
    background: #0f1720;
    color: #dff7ff;
    border-radius: 10px;
    padding: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    font-family: Inter, Arial, sans-serif;
    display: none;
  }
  #gpt-admin-shell h4 { margin:0 0 8px 0; color:#bfe8ff; font-size:16px; }
  #gpt-admin-shell input[type="text"], #gpt-admin-shell textarea {
    width:100%;
    box-sizing: border-box;
    border-radius:6px;
    border:1px solid rgba(255,255,255,0.06);
    background: rgba(8,18,26,0.9);
    color:#dff7ff;
    padding:8px;
    margin-top:6px;
    font-family: inherit;
    font-size:14px;
  }
  #gpt-admin-shell textarea { height:110px; resize:vertical; }
  #gpt-admin-shell .gpt-row { display:flex; gap:8px; margin-top:10px; }
  #gpt-admin-shell button {
    background:#1da1ff;
    color:#04202a;
    border:none;
    padding:9px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:700;
    width:100%;
  }
  #gpt-admin-shell .small-btn { background:#33414a; color:#fff; padding:8px; border-radius:6px; width:auto; }
  #gpt-admin-shell .gpt-status { margin-top:8px; color:#bcd8e8; font-size:13px; }
  #gpt-admin-shell #gptConsole { margin-top:8px; max-height:140px; overflow:auto; padding:8px; background:rgba(255,255,255,0.02); border-radius:6px; font-size:12px; color:#dff7ff; }
</style>

<!-- small visible lock icon ‚Äî clicking opens admin shell input -->
<div id="gpt-admin-lock" title="Admin (–≤–≤–æ–¥ –∫–æ–¥–∞)" aria-hidden="false">üîí</div>

<div id="gpt-admin-shell" aria-hidden="true" role="dialog" aria-label="Admin panel">
  <h4>–¢–æ–ª—å–∫–æ –¥–ª—è —Å–æ–∑–¥–∞—Ç–µ–ª—è</h4>

  <div>
    <label style="font-size:13px;color:#9fdbe9">–í–≤–µ–¥–∏—Ç–µ –∞–¥–º–∏–Ω-–∫–æ–¥</label>
    <input id="gpt-admin-code" type="text" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞" autocomplete="off" />
    <div class="gpt-row">
      <button id="gpt-admin-unlock">–í–≤–µ—Å—Ç–∏ –∫–æ–¥</button>
      <button id="gpt-admin-hide" class="small-btn">–°–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <div id="gpt-admin-panel" style="display:none;margin-top:10px">
    <label style="font-size:13px;color:#9fdbe9">–í—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∫–ª–∏–µ–Ω—Ç–∞</label>
    <textarea id="gpt-client-text" placeholder="–ü—Ä–∏–º–µ—Ä: –ê–ª—å—Ñ–∞–±–∞–Ω–∫ 5.5% 3 588 000 –∂–∏–∑–Ω—å –∏ –∏–º—É—â –∫–≤–∞—Ä—Ç–∏—Ä–∞ 2025 –º—É–∂ 02.02.1989"></textarea>

    <div class="gpt-row">
      <button id="gpt-autofill-btn">üß† –ê–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–∏—Ç—å –∏ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
      <button id="gpt-save-local" class="small-btn">‚ûï –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –ø–∞–º—è—Ç—å</button>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <button id="gpt-show-mem" class="small-btn">üìö –ü–æ–∫–∞–∑–∞—Ç—å –ø–∞–º—è—Ç—å</button>
      <button id="gpt-clear-mem" class="small-btn">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å</button>
      <div id="gpt-status" class="gpt-status">–°—Ç–∞—Ç—É—Å: –æ–∂–∏–¥–∞–Ω–∏–µ</div>
    </div>

    <div id="gptConsole" aria-live="polite"></div>
  </div>
</div>

<script>
(function(){
  /* Config */
  const ADMIN_CODE = 'INGO';
  const PARSE_ENDPOINT = 'https://ingostrakh-calc.onrender.com/parse'; // server endpoint
  const STORAGE_KEY = 'gpt_admin_examples_v1';
  const MAX_LOCAL = 300;

  /* Elements */
  const lock = document.getElementById('gpt-admin-lock');
  const shell = document.getElementById('gpt-admin-shell');
  const codeInput = document.getElementById('gpt-admin-code');
  const unlockBtn = document.getElementById('gpt-admin-unlock');
  const hideBtn = document.getElementById('gpt-admin-hide');
  const panel = document.getElementById('gpt-admin-panel');
  const clientText = document.getElementById('gpt-client-text');
  const autofillBtn = document.getElementById('gpt-autofill-btn');
  const saveLocalBtn = document.getElementById('gpt-save-local');
  const showMemBtn = document.getElementById('gpt-show-mem');
  const clearMemBtn = document.getElementById('gpt-clear-mem');
  const statusEl = document.getElementById('gpt-status');
  const consoleEl = document.getElementById('gptConsole');

  /* Helpers */
  function log(msg){
    const d = document.createElement('div');
    d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    consoleEl.prepend(d);
    console.log('[GPT-ADMIN]', msg);
  }
  function loadLocal(){ try{return JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]');}catch(e){return [];} }
  function saveLocal(example){ try{ const arr = loadLocal(); arr.push({text:example, ts:new Date().toISOString()}); localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(-MAX_LOCAL))); log('Saved to local memory'); }catch(e){ console.warn(e);} }
  function clearLocal(){ localStorage.removeItem(STORAGE_KEY); log('Local memory cleared'); }
  function showLocalWindow(){
    const arr = loadLocal();
    if(!arr.length){ alert('–ü–∞–º—è—Ç—å –ø—É—Å—Ç–∞'); return; }
    const w = window.open('','_blank','width=800,height=600');
    w.document.title = 'GPT - memory';
    w.document.body.style.whiteSpace = 'pre-wrap';
    w.document.body.style.fontFamily = 'monospace';
    w.document.body.innerText = arr.slice(-200).map((x,i)=>`${i+1}. ${x.ts}\n${x.text}`).join('\n\n----\n\n');
  }

  /* UI behaviors */
  lock.addEventListener('click', ()=> {
    shell.style.display = shell.style.display === 'block' ? 'none' : 'block';
    shell.setAttribute('aria-hidden', shell.style.display === 'block' ? 'false' : 'true');
  });
  hideBtn.addEventListener('click', ()=> { shell.style.display='none'; shell.setAttribute('aria-hidden','true'); });

  
  unlockBtn.addEventListener('click', ()=>{
    const v = (codeInput.value||'').trim().toUpperCase();
    if(v === ADMIN_CODE){
      panel.style.display = 'block';
      shell.style.display = 'block';
      shell.setAttribute('aria-hidden','false');
      codeInput.value = '';
      statusEl.textContent = '–°—Ç–∞—Ç—É—Å: Admin –¥–æ—Å—Ç—É–ø –æ—Ç–∫—Ä—ã—Ç';
      log('Admin unlocked');
      sessionStorage.setItem('gpt_admin_unlocked','1');
    } else {
      statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥';
      panel.style.display = 'none';
      shell.setAttribute('aria-hidden','true');
      log('Admin unlock failed ‚Äî –¥–æ—Å—Ç—É–ø –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω');
      sessionStorage.removeItem('gpt_admin_unlocked');
    }
  });

  // persist unlock during session (not permanent)
  if(sessionStorage.getItem('gpt_admin_unlocked') === '1'){
    shell.style.display='block';
    panel.style.display='block';
    shell.setAttribute('aria-hidden','false');
    statusEl.textContent = '–°—Ç–∞—Ç—É—Å: Admin (session)';
  }

  /* Main autofill logic */
  async function callParseServer(text){
    statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...';
    log('Sending text to parse endpoint');
    try{
      const resp = await fetch(PARSE_ENDPOINT, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({text})
      });
      if(!resp.ok){
        const t = await resp.text().catch(()=>'');
        statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É';
        log('Server error: ' + resp.status + ' ' + t);
        return null;
      }
      const j = await resp.json();
      if(!j || j.ok !== true || !j.data){
        statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞';
        log('Bad JSON response: ' + JSON.stringify(j));
        return null;
      }
      statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –û—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω';
      log('Parsed: ' + JSON.stringify(j.data));
      return j.data;
    }catch(err){
      statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –∏–ª–∏ CORS';
      log('Network error: ' + err);
      return null;
    }
  }

  // Attempt to set a field by many heuristics (won't destroy existing logic)
  function trySetField(selectors, value){
    for(const sel of selectors){
      try{
        const el = document.querySelector(sel);
        if(!el) continue;
        const tag = el.tagName.toLowerCase();
        if(tag === 'select'){
          // try match option by text or value
          const v = String(value).toLowerCase();
          let found=false;
          for(let i=0;i<el.options.length;i++){
            const opt = el.options[i];
            if((opt.text||'').toLowerCase().includes(v) || (opt.value||'').toLowerCase() === v){
              el.selectedIndex = i;
              el.value = opt.value;
              el.dispatchEvent(new Event('change',{bubbles:true}));
              found = true;
              break;
            }
          }
          if(found) return true;
          // fallback set
          el.value = value;
          el.dispatchEvent(new Event('change',{bubbles:true}));
          return true;
        }
        if(tag === 'input' || tag === 'textarea'){
          el.focus();
          el.value = value;
          el.dispatchEvent(new Event('input',{bubbles:true}));
          el.dispatchEvent(new Event('change',{bubbles:true}));
          return true;
        }
        // if other element, try innerText
        try{ el.innerText = value; return true; }catch(e){}
      }catch(e){ console.warn('trySetField err', e); }
    }
    return false;
  }

  function autofillToForm(parsed){
    if(!parsed) return {ok:false, reason:'no parsed'};
    // safe selectors for common fields (adaptable)
    const map = [
      {key:'loan', selectors: ['input[name="sum"]','input[name="amount"]','#sum','input[id*="sum"]','input[placeholder*="—Ä—É–±"]']},
      {key:'bank', selectors: ['select[name="bank"]','select[id*="bank"]','#bank','input[name="bank"]']},
      {key:'rate', selectors: ['input[name="rate"]','input[id*="rate"]','#rate','input[placeholder*="%"]']},
      {key:'propType', selectors: ['select[name="propertyType"]','select[id*="property"]','#propertyType']},
      {key:'year', selectors: ['input[name="year"]','input[id*="year"]','#year']},
      {key:'material', selectors: ['input[name="material"]','input[id*="material"]']},
      {key:'birth', selectors: ['input[name="birth"]','input[id*="birth"]','input[placeholder*="–¥–¥"]']},
      {key:'gender', selectors: ['select[name="gender"]','select[id*="gender"]','#gender']}
    ];
    const results = {};
    map.forEach(m=>{
      if(parsed[m.key] !== undefined && parsed[m.key] !== null && parsed[m.key] !== ''){
        const ok = trySetField(m.selectors, parsed[m.key]);
        results[m.key] = ok;
      }
    });
    return results;
  }

  // find and click Calculate button robustly
  function clickCalculate(){
    const keywords = ['—Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å','—Ä–∞—Å—á–∏—Ç–∞—Ç—å','calculate','–ø–æ—Å—á–∏—Ç–∞—Ç—å','–ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—á–µ—Ç','–ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—á–µ—Ç']; // russian variants
    // 1) search buttons and inputs
    const candidates = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], a'));
    for(const c of candidates){
      try{
        const txt = ((c.innerText||c.value||'') + '').toLowerCase().trim();
        if(!txt) continue;
        for(const k of keywords){
          if(txt.includes(k)){
            c.click();
            return {ok:true, method:'text_match', node: c};
          }
        }
      }catch(e){}
    }
    // 2) search by id/class fragments
    const alt = document.querySelector('[id*="calc"], [class*="calc"], [id*="calculate"], [class*="calculate"], [id*="submit"], [class*="submit"]');
    if(alt){ try{ alt.click(); return {ok:true, method:'selector_match', node: alt}; }catch(e){} }
    // 3) try form submit
    const form = document.querySelector('form');
    if(form){ try{ form.submit(); return {ok:true, method:'form_submit'}; }catch(e){} }
    return {ok:false};
  }

  /* Button handlers */
  autofillBtn.addEventListener('click', async ()=>{
    const t = (clientText.value||'').trim();
    if(!t){ statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∫–ª–∏–µ–Ω—Ç–∞'; return; }
    statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –æ–±—Ä–∞–±–æ—Ç–∫–∞...';
    const parsed = await callParseServer(t);
    if(!parsed){ statusEl.textContent = '–°—Ç–∞—Ç—É—Å: —Ä–∞–∑–±–æ—Ä –Ω–µ —É–¥–∞–ª—Å—è'; return; }
    // save local memory
    saveLocal(t);
    // fill fields
    const res = autofillToForm(parsed);
    log('Autofill result: ' + JSON.stringify(res));
    // click calculate
    const clk = clickCalculate();
    if(clk.ok){
      statusEl.textContent = '–ì–æ—Ç–æ–≤–æ: –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –∏ –Ω–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ (' + clk.method + ')';
      log('Calc clicked by ' + clk.method);
    } else {
      statusEl.textContent = '–ì–æ—Ç–æ–≤–æ: –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ, –Ω–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ —Ä–∞—Å—á—ë—Ç–∞';
      log('Calc button not found');
    }
  });

  saveLocalBtn.addEventListener('click', ()=>{
    const t = (clientText.value||'').trim();
    if(!t){ alert('–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è'); return; }
    saveLocal(t);
    statusEl.textContent = '–°—Ç–∞—Ç—É—Å: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ';
  });

  showMemBtn.addEventListener('click', showLocalWindow);
  clearMemBtn.addEventListener('click', ()=>{ if(confirm('–û—á–∏—Å—Ç–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å?')){ clearLocal(); statusEl.textContent='–ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞'; } });

  /* Expose a debug helper if needed */
  window.__gpt_admin = {
    callParseServer, saveLocal, loadLocal, autofillToForm, clickCalculate
  };

})();
</script>
<!-- ========== END: Admin-only GPT Autofil block ========== -->

<script>
// --- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±–∞–Ω–∫–∞ –ø–æ —Ç–µ–∫—Å—Ç—É –∫–ª–∏–µ–Ω—Ç–∞ ---
function detectAndSetBankFromText() {
  try {
    const textarea = document.querySelector('.admin-panel textarea');
    const bankSelect = document.querySelector('#bank');
    if (!textarea || !bankSelect) return;

    const text = textarea.value.toLowerCase();

    const banks = {
      "—Å–±–µ—Ä": "–°–±–µ—Ä–±–∞–Ω–∫",
      "–≤—Ç–±": "–í–¢–ë",
      "–≥–∞–∑–ø—Ä–æ–º": "–ì–∞–∑–ø—Ä–æ–º–±–∞–Ω–∫",
      "–∞–ª—å—Ñ–∞": "–ê–ª—å—Ñ–∞-–ë–∞–Ω–∫",
      "–¥–æ–º —Ä—Ñ": "–î–æ–º.–†–§",
      "—É—Ä–∞–ª—Å–∏–±": "–£–†–ê–õ–°–ò–ë",
      "—Å–æ–≤–∫–æ–º": "–°–æ–≤–∫–æ–º–±–∞–Ω–∫",
      "—Ä–æ—Å–±–∞–Ω–∫": "–†–æ—Å–±–∞–Ω–∫",
      "–æ—Ç–∫—Ä—ã—Ç–∏–µ": "–û—Ç–∫—Ä—ã—Ç–∏–µ",
      "–ø—Å–±": "–ü–°–ë",
      "—Ç–∏–Ω—å–∫–æ—Ñ—Ñ": "–¢–∏–Ω—å–∫–æ—Ñ—Ñ",
      "–º–∫–±": "–ú–ö–ë",
      "–≥–ø–±": "–ì–∞–∑–ø—Ä–æ–º–±–∞–Ω–∫"
    };

    let foundBank = null;
    for (const [key, value] of Object.entries(banks)) {
      if (text.includes(key)) {
        foundBank = value;
        break;
      }
    }

    if (foundBank) {
      for (const option of bankSelect.options) {
        if (option.text.toLowerCase().includes(foundBank.toLowerCase())) {
          bankSelect.value = option.value;
          console.log("‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±—Ä–∞–Ω –±–∞–Ω–∫:", foundBank);
          return;
        }
      }
      console.warn("‚ö†Ô∏è –ë–∞–Ω–∫ –Ω–∞–π–¥–µ–Ω –ø–æ —Ç–µ–∫—Å—Ç—É, –Ω–æ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å option:", foundBank);
    } else {
      console.warn("‚ùå –ë–∞–Ω–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–µ–∫—Å—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞.");
    }
  } catch (e) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–µ –±–∞–Ω–∫–∞:", e);
  }
}

// --- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–∑–æ–≤ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è ---
document.addEventListener('click', (e) => {
  if (e.target && e.target.textContent && e.target.textContent.toLowerCase().includes('–∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–∏—Ç—å')) {
    setTimeout(detectAndSetBankFromText, 500);
  }
});
</script>


<script>
// ===== v7: Smart autofill + on-device training =====
// Local memory keys
const BANK_MEMORY_KEY = 'gpt_bank_memory_v1';

function loadBankMemory(){
  try{ return JSON.parse(localStorage.getItem(BANK_MEMORY_KEY) || '{}'); } catch(e){ return {}; }
}
function saveBankMemory(mem){ try{ localStorage.setItem(BANK_MEMORY_KEY, JSON.stringify(mem)); }catch(e){} }

// Normalize helper
function norm(s){ return (s||'').toString().toLowerCase().replace(/[^\w\u0400-\u04FF]+/g,' ').trim(); }
function tokens(s){ return norm(s).split(/\s+/).filter(Boolean); }

// Built-in bank map (value -> option value will be matched later)
const BUILT_IN = {
  "—É—Ä–∞–ª—Å–∏–±": "uralsib",
  "–≤—Ç–±": "vtb",
  "—Å–±–µ—Ä": "sberbank",
  "—Å–±–µ—Ä–±–∞–Ω–∫": "sberbank",
  "–¥–æ–º —Ä—Ñ": "domrf",
  "–¥–æ–º.—Ä—Ñ": "domrf",
  "–≥–∞–∑–ø—Ä–æ–º": "gazprombank",
  "–≥–∞–∑–ø—Ä–æ–º–±–∞–Ω–∫": "gazprombank",
  "–∞–ª—å—Ñ–∞": "alfabank",
  "–∞–ª—å—Ñ–∞-–±–∞–Ω–∫": "alfabank",
  "—Å–æ–≤–∫–æ–º": "sovcombank",
  "—Å–æ–≤–∫–æ–º–±–∞–Ω–∫": "sovcombank",
  "—Ä–æ—Å–±–∞–Ω–∫": "rosbank",
  "–æ—Ç–∫—Ä—ã—Ç–∏–µ": "otkritie",
  "–ø–æ—á—Ç–∞": "pochtabank",
  "–ø—Å–±": "psb",
  "—Ç–∏–Ω—å–∫–æ—Ñ—Ñ": "tinkoff",
  "–º–∫–±": "mkb",
  "–≥–ø–±": "gpbank"
};

function detectBankFromText(text){
  if(!text) return '';
  const mem = loadBankMemory();
  const lower = norm(text);
  // 1. check memory exact keys
  for(const k of Object.keys(mem)){
    if(lower.includes(k)) return mem[k];
  }
  // 2. built-in keys
  for(const k of Object.keys(BUILT_IN)){
    if(lower.includes(k)) return BUILT_IN[k];
  }
  // 3. token heuristic: look for any token that equals beginning of bank names
  const tks = tokens(text);
  for(const tk of tks){
    if(BUILT_IN[tk]) return BUILT_IN[tk];
  }
  return '';
}

// Robustly set select by matching option text or value fragments
function setSelectByBankKey(selectEl, bankKey){
  if(!selectEl || !bankKey) return false;
  const bk = norm(bankKey);
  // try exact value match
  for(let i=0;i<selectEl.options.length;i++){
    const opt = selectEl.options[i];
    if(!opt) continue;
    const v = norm(opt.value);
    if(v === bk || v.includes(bk) || bk.includes(v)){
      selectEl.selectedIndex = i; selectEl.value = opt.value; selectEl.dispatchEvent(new Event('change',{bubbles:true})); return true;
    }
  }
  // match by text
  for(let i=0;i<selectEl.options.length;i++){
    const opt = selectEl.options[i];
    const t = norm(opt.text || opt.value || '');
    if(t.includes(bk) || bk.includes(t)){
      selectEl.selectedIndex = i; selectEl.value = opt.value; selectEl.dispatchEvent(new Event('change',{bubbles:true})); return true;
    }
  }
  // token intersection
  const bankToks = tokens(bankKey);
  for(let i=0;i<selectEl.options.length;i++){
    const opt = selectEl.options[i];
    const optToks = tokens(opt.text || opt.value || '');
    for(const bt of bankToks){
      if(optToks.includes(bt)){ selectEl.selectedIndex = i; selectEl.value = opt.value; selectEl.dispatchEvent(new Event('change',{bubbles:true})); return true; }
    }
  }
  return false;
}

// Save association from rawToken -> bankKey for future
function learnBankMapping(rawText, bankKey){
  try{
    if(!rawText || !bankKey) return;
    const mem = loadBankMemory();
    const lower = norm(rawText);
    // choose representative token: longest token in text that is a substring of bankKey or vice versa
    const tks = tokens(rawText);
    let chosen = '';
    for(const tk of tks){
      if(bankKey.includes(tk) || tk.length>chosen.length) chosen = tk;
    }
    if(chosen) mem[chosen] = bankKey;
    saveBankMemory(mem);
    console.log('GPT-admin: learned mapping', chosen, '‚Üí', bankKey);
  }catch(e){ console.warn(e); }
}

// Fill fields helper: tries many selectors then specific ids
function trySet(idOrSelector, value){
  if(value===null || value===undefined) return false;
  try{
    let el = document.querySelector(idOrSelector);
    if(!el && idOrSelector[0] !== '#') el = document.querySelector('#' + idOrSelector);
    if(!el) return false;
    const tag = el.tagName.toLowerCase();
    if(tag==='select' || tag==='input' || tag==='textarea'){
      el.focus();
      el.value = value;
      el.dispatchEvent(new Event('input',{bubbles:true}));
      el.dispatchEvent(new Event('change',{bubbles:true}));
      return true;
    } else {
      el.innerText = value; return true;
    }
  }catch(e){ console.warn('trySet err', e); return false; }
}

// main pipeline executed when clicking autofill
async function autofillPipeline(text){
  const statusEl = document.getElementById('gpt-status');
  if(statusEl) statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –æ–±—Ä–∞–±–æ—Ç–∫–∞...';
  let parsed = {};
  // 1) try server parse (non-blocking but prefer)
  try{
    const res = await fetch(typeof PARSE_ENDPOINT !== 'undefined' ? PARSE_ENDPOINT : '/parse', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({text})
    });
    if(res && res.ok){
      const j = await res.json();
      parsed = j && j.data ? j.data : {};
    }
  }catch(e){
    console.warn('parse server error', e);
  }
  // 2) local detection + merge
  const localBank = detectBankFromText(text);
  if(localBank && !parsed.bank) parsed.bank = localBank;
  // also extract simple patterns (dates, numbers, '–∂–µ–Ω' '–º—É–∂' '–∂' '–º', '—Å—Ç–∞–≤–∫–∞ X')
  // birth date regex dd.mm.yyyy or yyyy-mm-dd
  const birthMatch = text.match(/(\d{2}[.\-/]\d{2}[.\-/]\d{4})/);
  if(birthMatch && !parsed.birth) parsed.birth = birthMatch[1];
  const rateMatch = text.match(/—Å—Ç–∞–≤–∫[a–∞]\s*[:\- ]*\s*(\d+[.,]?\d*)/i);
  if(rateMatch && !parsed.rate) parsed.rate = rateMatch[1].replace(',', '.');
  if(/–∂–µ–Ω|–∂\W|female/i.test(text) && !parsed.gender) parsed.gender = 'female';
  if(/–º—É–∂|–º\W|male/i.test(text) && !parsed.gender) parsed.gender = 'male';
  // loan sum digits (–≤ –∫–æ–Ω—Ü–µ –∏–ª–∏ with spaces)
  const loanMatch = text.match(/(\d{5,12})/g);
  if(loanMatch && !parsed.loan){
    // pick largest number as loan
    const nums = loanMatch.map(x=>Number(x.replace(/[^\d]/g,'')));
    parsed.loan = Math.max(...nums);
  }

  console.log('Autofill parsed:', parsed);

  // 3) set bank robustly first so downstream logic (like bankMarkup) can work
  const bankSelect = document.querySelector('#bank');
  if(parsed.bank){
    const setOk = setSelectByBankKey(bankSelect, parsed.bank) || setSelectByBankKey(bankSelect, parsed.bank.toString());
    if(!setOk){
      // try direct string
      setSelectByBankKey(bankSelect, parsed.bank.toString());
    } else {
      // learn mapping from raw text to this bank key
      learnBankMapping(text, parsed.bank);
    }
  } else {
    // no bank found, try tokens heuristics
    const cand = detectBankFromText(text);
    if(cand){ setSelectByBankKey(bankSelect, cand); learnBankMapping(text, cand); parsed.bank = cand; }
  }

  // small wait to let DOM settle
  await new Promise(r=>setTimeout(r, 220));

  // 4) fill other fields by id
  if(parsed.loan) trySet('#loan', parsed.loan);
  if(parsed.birth) trySet('#birth', parsed.birth);
  if(parsed.start) trySet('#start', parsed.start);
  if(parsed.gender) trySet('#gender', parsed.gender);
  if(parsed.propType) trySet('#propType', parsed.propType);
  // check flags
  if(parsed.life || /–∂–∏–∑–Ω/i.test(text)) trySet('#life', true);
  if(parsed.prop || /–∏–º—É—â–µ/i.test(text)) trySet('#prop', true);
  if(parsed.title || /—Ç–∏—Ç—É–ª|—Ç–∏—Ç—É–ª/i.test(text)) trySet('#title', true);

  // market/land values if present
  const moneyMatch = text.match(/(\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d+)?)/);
  if(moneyMatch && !parsed.marketHouse){
    const m = moneyMatch[1].replace(/\s/g,'').replace(',','.');
    trySet('#marketHouse', m);
  }

  // 5) save locally mapping and raw example
  try{
    const memExamples = JSON.parse(localStorage.getItem('gpt_autofill_examples_v1')||'[]');
    memExamples.push({text, parsed, ts: new Date().toISOString()});
    localStorage.setItem('gpt_autofill_examples_v1', JSON.stringify(memExamples.slice(-300)));
  }catch(e){}

  // final small wait and trigger calculate
  await new Promise(r=>setTimeout(r, 380));
  const calcBtn = Array.from(document.querySelectorAll('button')).find(b=>/(—Ä–∞—Å—Å—á–∏—Ç|calculate|—Ä–∞—Å—á–∏—Ç—ã–≤)/i.test(b.innerText || b.value || '')) || document.getElementById('calc');
  if(calcBtn){ try{ calcBtn.click(); console.log('Calc clicked by autofill pipeline'); }catch(e){ console.warn(e); } }
  if(statusEl) statusEl.textContent = '–ì–æ—Ç–æ–≤–æ: –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–æ';
}

// attach to admin autofill button
(function attach(){
  const autofillBtn = document.getElementById('gpt-autofill-btn') || document.querySelector('[id^="gpt-autofill"]');
  if(!autofillBtn){
    console.warn('autofill v7: button not found');
    return;
  }
  autofillBtn.addEventListener('click', async (ev)=>{
    // get client text
    const clientText = document.getElementById('gpt-client-text') || document.querySelector('#gpt-client-text');
    const text = clientText ? clientText.value : '';
    // run pipeline (ensure runs after any existing handlers)
    setTimeout(()=>{ autofillPipeline(text); }, 150);
  });
})();
</script>


<!-- v8: Robust online-first autofill with fallback to local detection -->
<script>
(function(){
  const PARSE_ENDPOINT = 'https://ingostrakh-calc.onrender.com/parse';
  const STATUS_ID = 'gpt-status';
  const BANK_MEM_KEY = 'gpt_bank_memory_v1';

  function log(msg){
    const el = document.getElementById('gptConsole') || document.getElementById('gptConsole');
    if(el){
      const d = document.createElement('div');
      d.textContent = '['+ new Date().toLocaleTimeString() +'] ' + msg;
      el.prepend(d);
    }
    console.log('[GPT-V8]', msg);
  }

  function norm(s){ return (s||'').toString().toLowerCase().replace(/[^\w\u0400-\u04FF]+/g,' ').trim(); }
  function tokens(s){ return norm(s).split(/\s+/).filter(Boolean); }

  function loadBankMemory(){ try{ return JSON.parse(localStorage.getItem(BANK_MEM_KEY)||'{}'); }catch(e){return {};} }
  function saveBankMemory(mem){ try{ localStorage.setItem(BANK_MEM_KEY, JSON.stringify(mem)); }catch(e){} }

  // robust setter: try many matching strategies and ensure change event fires
  function robustSetBank(bankKey){
    try{
      if(!bankKey) return false;
      const sel = document.querySelector('#bank') || document.querySelector('select[id*="bank"]') || document.querySelector('select[name*="bank"]');
      if(!sel) return false;
      const bk = norm(String(bankKey));
      // 1. try exact value match
      for(let i=0;i<sel.options.length;i++){
        const opt = sel.options[i];
        if(!opt) continue;
        const v = norm(opt.value || '');
        if(v === bk || v.includes(bk) || bk.includes(v)){
          sel.selectedIndex = i; sel.value = opt.value; sel.dispatchEvent(new Event('change',{bubbles:true})); return true;
        }
      }
      // 2. by option text contains
      for(let i=0;i<sel.options.length;i++){
        const opt = sel.options[i];
        const t = norm(opt.text || opt.value || '');
        if(t.includes(bk) || bk.includes(t)){
          sel.selectedIndex = i; sel.value = opt.value; sel.dispatchEvent(new Event('change',{bubbles:true})); return true;
        }
      }
      // 3. token intersection
      const bT = tokens(bankKey);
      for(let i=0;i<sel.options.length;i++){
        const opt = sel.options[i];
        const oT = tokens(opt.text || opt.value || '');
        for(const bt of bT){
          if(oT.includes(bt)){
            sel.selectedIndex = i; sel.value = opt.value; sel.dispatchEvent(new Event('change',{bubbles:true})); return true;
          }
        }
      }
      // 4. memory keys
      const mem = loadBankMemory();
      for(const k of Object.keys(mem)){
        if(bk.includes(k)){
          const mapped = mem[k];
          // try to find mapped in options
          for(let i=0;i<sel.options.length;i++){
            const opt = sel.options[i];
            if(norm(opt.text||opt.value||'').includes(norm(mapped))){
              sel.selectedIndex = i; sel.value = opt.value; sel.dispatchEvent(new Event('change',{bubbles:true})); return true;
            }
          }
        }
      }
      return false;
    }catch(e){ console.warn('robustSetBank error', e); return false; }
  }

  // trySet for inputs/selects
  function trySet(selectorOrId, value){
    try{
      if(value===null || value===undefined) return false;
      let el = document.querySelector(selectorOrId);
      if(!el && selectorOrId[0] !== '#') el = document.querySelector('#'+selectorOrId);
      if(!el) return false;
      const tag = el.tagName.toLowerCase();
      if(tag === 'select'){
        // attempt to match option by text or value
        const v = String(value).toLowerCase();
        for(let i=0;i<el.options.length;i++){
          const opt = el.options[i];
          if((opt.text||'').toLowerCase().includes(v) || (opt.value||'').toLowerCase() === v){
            el.selectedIndex = i; el.value = opt.value; el.dispatchEvent(new Event('change',{bubbles:true})); return true;
          }
        }
        // fallback
        el.value = value; el.dispatchEvent(new Event('change',{bubbles:true})); return true;
      }
      if(tag === 'input' || tag === 'textarea'){
        el.focus();
        el.value = value;
        el.dispatchEvent(new Event('input',{bubbles:true}));
        el.dispatchEvent(new Event('change',{bubbles:true}));
        return true;
      }
      try{ el.innerText = value; return true; }catch(e){}
      return false;
    }catch(e){ console.warn('trySet err', e); return false; }
  }

  // simple local parser (fallback) to extract bank, loan, birth, gender, marketHouse & flags
  function localParse(text){
    const out = {};
    const t = String(text||'').toLowerCase();
    // bank detection by common tokens in the page's bank options
    const bankOptions = Array.from((document.querySelectorAll('#bank option')||[])).map(o=>o.textContent||o.value||'');
    for(const opt of bankOptions){
      const n = norm(opt);
      const toks = tokens(n);
      for(const tk of toks){
        if(t.indexOf(tk) !== -1 && tk.length>1){
          out.bank = opt;
          break;
        }
      }
      if(out.bank) break;
    }
    // regexes
    const loanMatch = text.match(/(\d{5,12}([ \u00A0]\d{3})?)/g);
    if(loanMatch){
      // take largest numeric group
      const nums = loanMatch.map(x=>Number(x.replace(/[^\d]/g,'')));
      out.loan = Math.max(...nums);
    }
    const birthMatch = text.match(/(\d{2}[.\-/]\d{2}[.\-/]\d{4})/);
    if(birthMatch) out.birth = birthMatch[1];
    if(/–∂–µ–Ω|–∂\W|female/i.test(text)) out.gender = 'female';
    if(/–º—É–∂|–º\W|male/i.test(text)) out.gender = 'male';
    if(/–∂–∏–∑–Ω|—Å—Ç—Ä–∞—Ö–æ–≤.*–∂–∏–∑–Ω/i.test(text)) out.life = true;
    if(/–∏–º—É—â–µ|–¥–æ–º|–∫–≤–∞—Ä—Ç–∏/i.test(text)) out.prop = true;
    if(/—Ç–∏—Ç—É–ª|title/i.test(text)) out.title = true;
    const moneyMatch = text.match(/(\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d+)?)/);
    if(moneyMatch) out.marketHouse = moneyMatch[1].replace(/\s/g,'').replace(',','.');
    return out;
  }

  // fetch parse server, POST JSON {text}, expecting {ok:true, data: {...}}
  async function callParseServer(text){
    try{
      const res = await fetch(PARSE_ENDPOINT, {
        method:'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({text})
      });
      if(!res.ok){
        const txt = await res.text().catch(()=>'');
        log('Server returned '+res.status+' '+txt);
        return null;
      }
      const j = await res.json();
      if(!j || j.ok !== true || !j.data) { log('Bad parse response'); return null; }
      return j.data;
    }catch(err){
      log('Server parse error: ' + err.message);
      return null;
    }
  }

  // wait until condition true or timeout
  function waitFor(conditionFn, timeout=1200, interval=80){
    return new Promise((resolve)=>{
      const start = Date.now();
      (function check(){
        try{
          if(conditionFn()) return resolve(true);
          if(Date.now() - start > timeout) return resolve(false);
          setTimeout(check, interval);
        }catch(e){ return resolve(false); }
      })();
    });
  }

  async function runAutofill(text){
    const status = document.getElementById(STATUS_ID);
    if(status) status.textContent = '–°—Ç–∞—Ç—É—Å: –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...';
    log('Autofill started');
    let parsed = await callParseServer(text);
    if(!parsed){
      if(status) status.textContent = '–°—Ç–∞—Ç—É—Å: —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî –æ—Ñ—Ñ–ª–∞–π–Ω fallback';
      log('Falling back to local parser');
      parsed = localParse(text);
    } else {
      if(status) status.textContent = '–°—Ç–∞—Ç—É—Å: –æ—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω';
    }

    // save example to local storage memory for future token mapping
    try{
      const mem = JSON.parse(localStorage.getItem('gpt_admin_examples_v1')||'[]');
      mem.push({text, parsed, ts: new Date().toISOString()});
      localStorage.setItem('gpt_admin_examples_v1', JSON.stringify(mem.slice(-500)));
    }catch(e){}

    // determine bankKey string (server may return key or full name)
    const bankCandidate = parsed.bank || parsed.bank_name || parsed.bankName || parsed.bankNameRaw || parsed.bankFull || parsed.bankFullName || parsed.bank_label || parsed.bankLabel || parsed.bankText || null;

    // try robust set
    let setOk = false;
    if(bankCandidate){
      setOk = robustSetBank(bankCandidate);
      if(setOk) log('Bank set from parsed bankCandidate: ' + bankCandidate);
    }
    // if not set, try detectBankFromText function if present
    if(!setOk && typeof detectBankFromText === 'function'){
      const cand = detectBankFromText(text);
      if(cand){
        setOk = robustSetBank(cand);
        if(setOk) log('Bank set from detectBankFromText: ' + cand);
      }
    }
    // if still not set, try localParse bank
    if(!setOk && parsed.bank){
      setOk = robustSetBank(parsed.bank);
    }
    // as last resort, try matching any option token inside text
    if(!setOk){
      const bankOptions = Array.from(document.querySelectorAll('#bank option')).map(o=>o.textContent||o.value||'');
      for(const opt of bankOptions){
        const n = norm(opt);
        if(text.toLowerCase().indexOf(n) !== -1 && n.length>1){
          setOk = robustSetBank(opt);
          if(setOk){ log('Bank set by option-text match: '+opt); break; }
        }
      }
    }

    // wait for bank value to be non-empty
    const bankEl = document.querySelector('#bank');
    if(setOk && bankEl){
      await waitFor(()=> (bankEl.value && bankEl.value.toString().trim() !== ''), 1200, 60);
    }

    // fill other fields
    if(parsed.loan) trySet('#loan', parsed.loan);
    if(parsed.birth) trySet('#birth', parsed.birth);
    if(parsed.start) trySet('#start', parsed.start);
    if(parsed.gender) trySet('#gender', parsed.gender);
    if(parsed.propType) trySet('#propType', parsed.propType);
    if(parsed.rate) trySet('#rate', parsed.rate);
    if(parsed.marketHouse) trySet('#marketHouse', parsed.marketHouse);
    if(parsed.life || /–∂–∏–∑–Ω/i.test(text)) trySet('#life', true);
    if(parsed.prop || /–∏–º—É—â–µ/i.test(text)) trySet('#prop', true);
    if(parsed.title || /—Ç–∏—Ç—É–ª/i.test(text)) trySet('#title', true);

    // final delay to allow bank change handlers to run and update bankMarkup etc.
    await new Promise(r=>setTimeout(r, 420));

    // click calculate reliably
    const calc = document.getElementById('calc') || Array.from(document.querySelectorAll('button')).find(b=>/(—Ä–∞—Å—Å—á–∏—Ç|—Ä–∞—Å—á–∏—Ç–∞—Ç—å|calculate)/i.test(b.innerText || b.value || ''));
    if(calc){
      try{ calc.click(); log('Clicked calc'); if(status) status.textContent = '–ì–æ—Ç–æ–≤–æ: –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –∏ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–æ'; }catch(e){ log('Calc click failed: ' + e.message); if(status) status.textContent = '–ì–æ—Ç–æ–≤–æ: –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, –Ω–æ –Ω–µ –Ω–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞'; }
    } else {
      log('Calc button not found');
      if(status) status.textContent = '–ì–æ—Ç–æ–≤–æ: –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, –Ω–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ —Ä–∞—Å—á—ë—Ç–∞';
    }

    // if we learned a bank mapping from parsed or detected bank, store a short token mapping
    try{
      const mem = loadBankMemory();
      const toks = tokens(text);
      if(toks.length){
        const key = toks.find(t=> t.length>2 ) || toks[0];
        if(bankCandidate || (document.querySelector('#bank') && document.querySelector('#bank').value)){
          const mapped = bankCandidate || (document.querySelector('#bank') && (document.querySelector('#bank').selectedOptions[0].text || document.querySelector('#bank').value));
          if(key && mapped){ mem[key] = mapped; saveBankMemory(mem); log('Learned mapping: ' + key + ' ‚Üí ' + mapped); }
        }
      }
    }catch(e){ console.warn(e); }

    return true;
  }

  // attach to admin button (override existing handler by adding an extra listener)
  function attachHandler(){
    const btn = document.getElementById('gpt-autofill-btn') || document.querySelector('[id^="gpt-autofill"]');
    if(!btn){ console.warn('v8 attach: autofill button not found'); return; }
    btn.addEventListener('click', async (ev)=>{
      ev.preventDefault();
      const ta = document.getElementById('gpt-client-text') || document.querySelector('#gpt-client-text');
      const txt = ta ? ta.value || '' : '';
      if(!txt || txt.trim()===''){ const st = document.getElementById('gpt-status'); if(st) st.textContent='–°—Ç–∞—Ç—É—Å: –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∫–ª–∏–µ–Ω—Ç–∞'; return; }
      await runAutofill(txt);
    });
    log('v8 autofill attached');
  }

  // wait DOM ready then attach
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachHandler);
  } else {
    attachHandler();
  }

  // expose for debugging
  window.__gpt_v8 = { runAutofill, robustSetBank, trySet, localParse };
})();
</script>


<!-- v9_fixed: Force-realistic bank selection and expanded synonyms -->
<script>
(function(){
  // Expanded synonyms map for robust detection
  const SYNONYMS = [
    ['—É—Ä–∞–ª—Å–∏–±','—É—Ä–∞–ª —Å–∏–±','—É—Ä–∞–ª—Å–∏–± –±–∞–Ω–∫','—É—Ä–∞–ª—Å–∏–±—Ä','—É—Ä–∞–ª—Å–∏–± —Ä—Ç'],
    ['–≤—Ç–±','–≤ —Ç –±','–≤—Ç–± –±–∞–Ω–∫'],
    ['—Å–±–µ—Ä','—Å–±–µ—Ä–±–∞–Ω–∫','—Å–±'],
    ['–∞–ª—å—Ñ–∞','–∞–ª—å—Ñ–∞ –±–∞–Ω–∫','–∞–ª—å—Ñ–∞–±–∞–Ω–∫','–∞–ª—å—Ña'],
    ['–¥–æ–º —Ä—Ñ','–¥–æ–º.—Ä—Ñ','–¥–æ–º—Ä—Ñ','–¥–æ–º—Ä—Ñ –±–∞–Ω–∫'],
    ['–ø—Å–±','–ø—Å–± –±–∞–Ω–∫','–ø—Ä–æ–º—Å–≤—è–∑—å'],
    ['–º–∫–±','–º–∫–± –±–∞–Ω–∫'],
    ['—é–Ω–∏–∫—Ä–µ–¥–∏—Ç','—é–Ω–∏ –∫—Ä–µ–¥–∏—Ç','—é–Ω–∏–∫—Ä–µ–¥–∏—Ç –±–∞–Ω–∫'],
    ['—Ä–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫','—Ä–æ—Å—Å–µ–ª—å—Ö–æ–∑','—Ä—Å—Ö–±','—Ä—Å—Ö–± –±–∞–Ω–∫'],
    ['—Ä–∞–π—Ñ—Ñ–∞–π–∑–µ–Ω','—Ä–∞–π—Ñ','—Ä–∞–π—Ñ–∞–π–∑–µ–Ω–±–∞–Ω–∫','—Ä–∞–π—Ñ–∞'],
    ['–∑e–Ω–∏—Ç','–∑–µ–Ω–∏—Ç','–∑–µ–Ω–∏—Ç –±–∞–Ω–∫','–∑–µ–Ω–∏—Ç–±–∞–Ω–∫'],
    ['–º—Ç—Å –±–∞–Ω–∫','–º—Ç—Å'],
    ['—Ç–∫—Ç–±','—Ç–∫–±','—Ç –∫ –±','—Ç –∫ –± –±–∞–Ω–∫','—Ç–∫–± –±–∞–Ω–∫'],
    ['—Ç—Ä–∞–Ω—Å–∫–∞–ø–∏—Ç–∞–ª','—Ç—Ä–∞–Ω—Å–∫–∞–ø–∏—Ç–∞–ª','—Ç–∫–∞–ø–∏—Ç–∞–ª']
  ];

  function norm(s){ return (s||'').toString().toLowerCase().replace(/[^\w\u0400-\u04FF]+/g,' ').trim(); }
  function tokens(s){ return norm(s).split(/\s+/).filter(Boolean); }

  // simulate real user interaction with select element
  function simulateSelectUserAction(selectEl, optionIndex){
    try{
      if(!selectEl) return false;
      selectEl.focus();
      // dispatch mousedown on select
      selectEl.dispatchEvent(new MouseEvent('mousedown', {bubbles:true, cancelable:true}));
      // set selected index
      if(optionIndex < 0 || optionIndex >= selectEl.options.length) return false;
      selectEl.selectedIndex = optionIndex;
      // set value explicitly
      selectEl.value = selectEl.options[optionIndex].value || selectEl.options[optionIndex].text;
      // dispatch input and change
      selectEl.dispatchEvent(new Event('input', {bubbles:true}));
      selectEl.dispatchEvent(new Event('change', {bubbles:true}));
      // small pause then blur
      setTimeout(()=>{ 
        try{ selectEl.dispatchEvent(new MouseEvent('mouseup', {bubbles:true})); }catch(e){}
        try{ selectEl.blur(); }catch(e){}
      }, 30);
      return true;
    }catch(e){ console.warn('simulateSelectUserAction error', e); return false; }
  }

  // Try to set bank by matching option text with a candidate token
  function setBankByCandidateText(candidate){
    if(!candidate) return false;
    const sel = document.querySelector('#bank') || document.querySelector('select[id*="bank"]') || document.querySelector('select[name*="bank"]');
    if(!sel) return false;
    const candNorm = norm(candidate);
    // first, try exact contains on option text
    for(let i=0;i<sel.options.length;i++){
      const opt = sel.options[i];
      const t = norm(opt.text || opt.value || '');
      if(t.includes(candNorm) || candNorm.includes(t)){
        return simulateSelectUserAction(sel, i);
      }
    }
    // token intersection
    const candToks = tokens(candidate);
    for(let i=0;i<sel.options.length;i++){
      const opt = sel.options[i];
      const optToks = tokens(opt.text || opt.value || '');
      for(const tk of candToks){
        if(optToks.includes(tk)){
          return simulateSelectUserAction(sel, i);
        }
      }
    }
    return false;
  }

  // Try to detect bank by scanning synonyms list against text
  function detectBankFromTextExpanded(text){
    if(!text) return '';
    const lower = norm(text);
    // scan synonyms groups in order
    for(const group of SYNONYMS){
      for(const syn of group){
        if(lower.indexOf(norm(syn)) !== -1){
          // return the canonical group first token
          return group[0];
        }
      }
    }
    // fallback: try any option token
    const sel = document.querySelector('#bank');
    if(sel){
      const bankOptions = Array.from(sel.options).map(o=>o.text || o.value || '');
      for(const opt of bankOptions){
        const optNorm = norm(opt);
        if(lower.indexOf(optNorm) !== -1 && optNorm.length>1) return opt;
      }
    }
    return '';
  }

  // Main override handler attached to admin autofill button
  function attachV9(){
    const btn = document.getElementById('gpt-autofill-btn') || document.querySelector('[id^="gpt-autofill"]');
    if(!btn){ console.warn('v9: autofill button not found'); return; }
    btn.addEventListener('click', async function(ev){
      ev.preventDefault();
      const ta = document.getElementById('gpt-client-text');
      const statusEl = document.getElementById('gpt-status');
      if(statusEl) statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –ø–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∞–Ω–∫–∞...';
      const txt = ta ? ta.value || '' : '';
      if(!txt || txt.trim()===''){ if(statusEl) statusEl.textContent='–°—Ç–∞—Ç—É—Å: –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∫–ª–∏–µ–Ω—Ç–∞'; return; }

      // 1) try server parse first (if available) by reusing existing callParseServer if present
      let parsed = null;
      if(typeof callParseServer === 'function'){
        try{
          parsed = await callParseServer(txt);
        }catch(e){
          parsed = null;
        }
      }

      // 2) if server returned bankCandidate, try to set it directly
      let bankSet = false;
      const candidates = [];
      if(parsed && parsed.bank) candidates.push(parsed.bank);
      if(parsed && parsed.bank_name) candidates.push(parsed.bank_name);
      // also include local expanded detection
      const det = detectBankFromTextExpanded(txt);
      if(det) candidates.push(det);
      // also push raw tokens from text that look like bank tokens (first few words)
      const rawToks = txt.split(/\s+/).slice(0,6);
      for(const r of rawToks) candidates.push(r);

      // attempt to set bank by candidates one by one
      for(const c of candidates){
        if(!c) continue;
        bankSet = setBankByCandidateText(c);
        if(bankSet) break;
      }

      // 3) if still not set, try full-scan synonyms
      if(!bankSet){
        const expanded = detectBankFromTextExpanded(txt);
        if(expanded){
          bankSet = setBankByCandidateText(expanded);
        }
      }

      // 4) if still not set, try direct option-text substring matching
      if(!bankSet){
        const sel = document.querySelector('#bank');
        if(sel){
          const lower = norm(txt);
          for(let i=0;i<sel.options.length;i++){
            const opt = sel.options[i];
            const optNorm = norm(opt.text || opt.value || '');
            if(optNorm.length>1 && lower.indexOf(optNorm) !== -1){
              bankSet = simulateSelectUserAction(sel, i);
              if(bankSet) break;
            }
          }
        }
      }

      // small wait
      await new Promise(r=>setTimeout(r, 300));

      // check if bank actually set
      const bankEl = document.querySelector('#bank');
      if(bankEl && bankEl.value && bankEl.value.toString().trim() !== ''){
        if(statusEl) statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –±–∞–Ω–∫ –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω: ' + (bankEl.selectedOptions[0].text || bankEl.value);
      } else {
        if(statusEl) statusEl.textContent = '–°—Ç–∞—Ç—É—Å: –±–∞–Ω–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä—É—á–Ω—É—é';
      }

      // proceed with existing autofillPipeline if present, else trigger the original pipeline via clickCalculate logic
      if(typeof autofillPipeline === 'function'){
        try{ await autofillPipeline(txt); }catch(e){ console.warn(e); }
      } else if(typeof runAutofill === 'function'){
        try{ await runAutofill(txt); }catch(e){ console.warn(e); }
      } else {
        // last resort: try to click calc after small delay
        await new Promise(r=>setTimeout(r, 400));
        const calcBtn = document.getElementById('calc');
        if(calcBtn) calcBtn.click();
      }
    }, {passive:false});
    console.log('v9_fixed attached');
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachV9);
  } else {
    attachV9();
  }

  // expose helpers for debugging in console
  window.__gpt_v9_fixed = { detectBankFromTextExpanded, setBankByCandidateText, simulateSelectUserAction };
})();
</script>

<script>
(function installDOMRFWrapper(){
    const tryInstall = ()=>{
      if(typeof getBasePercentForBank === 'function' && !getBasePercentForBank.__assistant_wrapped){
        const orig = getBasePercentForBank;
        getBasePercentForBank = function(bank, age, gender){
          try{
            if(bank === '–î–û–ú.–†–§' && age !== null && age >=21 && age <=64){
              if(gender === 'female'){
                if(typeof domrfFemale !== 'undefined' && domrfFemale[age] !== undefined) return domrfFemale[age];
              } else {
                if(typeof domrfMale !== 'undefined' && domrfMale[age] !== undefined) return domrfMale[age];
              }
            }
          }catch(e){}
          return orig(bank, age, gender);
        };
        getBasePercentForBank.__assistant_wrapped = true;
        try{
          const bankEl = document.getElementById('bank');
          if(bankEl && !bankEl.__assistant_event_attached){
            bankEl.addEventListener('change', ()=> {
              const b = bankEl.value;
              const vtbRow = document.getElementById('vtbRow');
              if(vtbRow) vtbRow.style.display = (b === '–í–¢–ë') ? 'block' : 'none';
              const lifeDiscountWrap = document.getElementById('lifeDiscountWrap');
              if(b === '–î–û–ú.–†–§' || b === '–ê–ª—å—Ñ–∞ –ë–∞–Ω–∫'){
                const lifeDiscountEl = document.getElementById('lifeDiscount');
                if(lifeDiscountEl){ lifeDiscountEl.checked=false; lifeDiscountEl.disabled=true; }
                if(lifeDiscountWrap) lifeDiscountWrap.style.display = (document.getElementById('life').checked)?'block':'none';
              } else {
                const lifeDiscountEl = document.getElementById('lifeDiscount');
                if(lifeDiscountEl) lifeDiscountEl.disabled=false;
              }
              if(b === '–†–æ—Å—Å–µ–ª—å—Ö–æ–∑–±–∞–Ω–∫'){
                const modal = document.getElementById('modalRshb');
                if(modal) modal.style.display = 'flex';
              }
              const propType = document.getElementById('propType');
              const materialBlock = document.getElementById('materialBlock');
              if(propType && materialBlock) materialBlock.style.display = (propType.value === 'house') ? 'block' : 'none';
            });
            bankEl.__assistant_event_attached = true;
          }
        }catch(e){}
      } else {
        setTimeout(tryInstall, 200);
      }
    };
    tryInstall();
  })();
</script>
</body>
</html>
